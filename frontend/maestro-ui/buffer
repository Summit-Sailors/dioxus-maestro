  rsx! {
    div {
      class: tw_join!("flex flex-col gap-2 w-full relative", props.container_class.clone().unwrap_or_default()),
      if let Some(label) = props.label.clone() {
        span {
          class: tw_join!("text-gray-400", props.label_class.clone().unwrap_or_default()),
          {label}
        }
      }
      div {
        class: tw_join!(
          "relative w-full bg-gray-800 text-gray-100 border border-gray-500 rounded-md hover:border-indigo-300 transition-colors ease-linear cursor-pointer",
          is_opened().then_some("ring-1 ring-indigo-500"),
          props.button_class.clone().unwrap_or_default()
        ),
        tabindex: -1,
        button {
          class: "relative flex bg-gray-800 text-gray-100 py-2 px-3 w-full h-full rounded-md focus:outline-none focus:ring-1 focus:ring-indigo-500",
          onfocusout: move |_| is_opened.set(false),
          onmousedown: move |ev| {
            ev.prevent_default();
            ev.stop_propagation();
            is_opened.toggle();
          },
          span { "{display_value}" }
          {icon_down}
        }
        div {
          class: tw_join!(
            "absolute flex flex-col gap-1 bg-gray-800 text-gray-200 p-4 w-full left-0 right-0 top-[100%] mt-3 rounded-md border border-gray-700 max-h-48 overflow-y-auto",
            if is_opened() { "flex z-40" } else { "hidden -z-40" },
            props.dropdown_class.clone().unwrap_or_default()
          ),
          onclick: move |ev| {
            ev.stop_propagation();
          },
          {
            props.options.iter().map(|option| {
              let option_clone = option.clone();
              rsx! {
                div {
                  key: "{option.value}",
                  id: "{option.value}",
                  class: tw_join!(
                    "flex w-full items-center py-2 hover:bg-gray-700 rounded px-3 cursor-pointer",
                    props.option_class.clone().unwrap_or_default()
                  ),
                  onclick: move |ev| {
                    ev.stop_propagation();
                    if props.multi {
                      let mut current = selected_options().clone();
                      if current.contains(&option_clone.value) {
                        current.retain(|x| x != &option_clone.value);
                      } else {
                        current.push(option_clone.value.clone());
                      }
                      selected_options.set(current.clone());
                      if let Some(multi_cb) = props.multi_callback.clone() {
                        multi_cb.call(current);
                      }
                    } else {
                      is_opened.set(false);
                      if let Some(callback) = props.callback.clone() {
                        callback.call(option_clone.value.clone());
                      }
                    }
                  },
                  {
                    if let Some(renderer) = props.option_renderer {
                      renderer(&option)
                    } else {
                      rsx! { "{option.label}" }
                    }
                  }
                  if props.icon_check.is_some() {
                    {props.icon_check.clone().unwrap()}
                  } else {
                    Icon {
                      icon: IoCheckmarkOutline,
                      class: tw_join!(
                        "fill-none ml-auto",
                        if props.multi && selected_options().contains(&option.value)
                          || !props.multi && props.current_value.as_ref() == Some(&option.value)
                        {
                          "opacity-100"
                        } else {
                          "opacity-0"
                        }
                      ),
                    }
                  }
                }
              }
            })
          }
        }
      }
    }
  }